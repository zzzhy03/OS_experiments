## 四、内存管理实验

1. 忽略注意事项
2. 内核空间中，Free memory段落，在最高地址区域，开辟16MB或8MB的堆
	- 原先整个Free memory段落纳入kmalloc()的管理，按页为单位分配回收
	- 现在要求从Free memory段落的顶部扣减8MB或16MB，kmalloc()仍按原机制分配回收，只是管理的内存总量少了8MB或16MB，现有内核代码都不受影响
	- 扣出来的8MB或16MB，另起炉灶，搭建一个堆，以字节为单位的分配释放机制
	- 堆和kmalloc()并行工作，各管理内核空间中的一片区域
3. 提供malloc()、free()函数，不需要类似sbrk()的堆扩容功能
4. 为了演示效果，须在内核中增加一个演示函数，连续执行一系列的堆分配、堆释放，并在屏幕上输出必要堆状态信息
5. 此外还需增加一个（或两个）系统调用，应用程序通过系统调用，启动演示

# 选做

## 进程优先级

1. 增加进程优先级机制，调度时考虑相关因素
2. 每个进程默认位于中间优先级（fork()的时候是否携带优先级信息？随便）
3. 提供系统调用，以升降本进程的优先级
4. 编写用户程序，fork()，然后父子进程调整不同优先级，并做大量循环，间歇输出循环进度，体现速度差异

## 共享内存页

1. 提供共享内存页机制，提供必要的系统调用，类似linux方法新建、加入
2. 把共享内存页映射到trapframe下方
3. 编写用户程序，fork()，然后父子进程建立共享页，开展通信，输出必要的信息以体现通信过程

## 信号量机制

1. 内核中已经提供了spinlock和sleeplock，但没有通过系统调用对用户空间开放相关功能
2. 为用户态程序增加信号量机制，新增若干系统调用，对sleeplock进行操纵
3. 编写用户程序，fork()，然后父子进程通过信号量控制进度，输出必要的信息以体现该过程
